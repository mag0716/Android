# Domain layer

https://developer.android.com/jetpack/guide/domain-layer

ドメイン層はUI層とデータ層の間にあるオプションの層。

ドメイン層は複雑なビジネスロジックや複数のViewModelで再利用される単純なビジネスロジックをカプセル化する役割を担っている。すべてのアプリにこのような要件があるわけではないのでこの層はオプション。この層は複雑さを処理したり、再利用性を高めるなど必要な場合にのみ使用する必要がある。

ドメイン層は以下の利点がある。

* コードの重複を避けることができる
* ドメイン層を使用するクラスの可読性を向上させる
* アプリのテスト容易性を向上させる
* 責務を分担することでクラスが巨大化するのを避ける

これらのクラスをシンプルかつ軽量に保つために各ユースケースは単一の機能に対してのみ責任を持つべきで変更可能なデータを含むべきではない。代わりにUIやデータ層でミュータブルデータを処理する必要がある。

Note: このページで紹介する推奨事項やベストプラクティスは幅広いアプリに適用し拡張性、品質と堅牢性の向上、およびテストの容易化を実現できる。ただしガイドラインとして扱い必要に応じて要件に適合させる必要がある。

## Naming conventions in this guide

このガイドではユースケースは担当する1つのアクションにちなんだ命名となる。

現在形の動詞+名詞(オプション)+`UseCase`

例えば、`FormatDateUseCase`, `GetLatestNewsWithAuthorsUseCase`, `MakeLoginRequestUseCase` など

## Dependencies

一般的なアーキテクデャではユースケースクラスはUI層のViewModelとデータ層のリポジトリとの間に位置する。つまり、ユースケースクラスはリポジトリクラスに依存し、リポジトリと同じようにコールバックやコルーチンを使ってUI層と通信する。

例えば、ニュースリポジトリと著者リポジトリからデータを取得し、それらを結合するユースケースがあるとする。

ユースケースには再利用可能なロジックが含まれているため他のユースケースで利用することも可能。ドメイン層に複数のレベルのユースケースが存在するのは普通。例えば、UI層の複数のクラスが画面に適切なメッセージを表示するためにタイムゾーンに依存している場合、FormatDateUseCaseユースケースを使用することができる。

## Call use cases in Kotlin

Kotlinでは`operator`と一緒に`invoke()`を定義することでユースケースクラスインスタンスを関数として呼び出せるようにすることができる。

この例では`invoke()`によってクラスのインスタンスをあたかも関数のように呼び出すことができる。`invoke()`メソッドは特定のシグネチャに制限さえることなく任意の数のパラメータを取り、任意の肩を返すことができる。また、クラス内でさまざまなシグネチャを指定して `invoke()` をオーバーロードすることもできる。

## Lifecycle

ユースケースは独自のライフサイクルを持たない。その代わりそれを使用するクラスに対してスコープが設定される。つまり、UI層のクラス、サービス、`Application`クラス自身からユースケースを呼び出すことができる。ユースケースは変更可能なデータを含むべきではないので依存関係として渡すたびにインスタンスを作成する必要がある。

## Threading

ドメイン層からのユースケースはmain safeでなければならない。言い換えるとメインスレッドから呼び出しても安全でなければならない。ユースケースが長時間実行されるブロック処理を行う場合、そのロジックを適切なスレッドに移動させる責任がある。しかし、その前にブロック処理を他の層に配置した方がよいかどうかを検討する必要がある。一般的に複雑な計算はデータ層で行い再利用やキャッシュを促す。例えば、大きなリストに対するリソース集約的な操作はアプリの複数の画面で再利用するために結果をキャッシュする必要があるばあい、ドメイン層よりもデータ層に配置した方がよい。

## Common tasks

このセクションではドメイン層の共通的なタスクをどう扱うのかを記述する。

### Reusable simple business logic

UI層に存在する繰り返し可能なビジネスロジックはユースケースクラスにカプセル化する必要がある。こうすることでそのロジックが使用される全ての場所で簡単に変更を適用することができる。またそのロジックを単独でテストすることもできる。

先ほどの`FormatDateUseCase`の例だと日付の書式に関する要件が変更された場合、一箇所に集中したコードを変更すれば良い。

Note: 場合によってはユースケースに存在するロジックをUtilクラスの静的めそっdの一部にすることができるがあまり推奨されない。Utilクラスは見つけにくく、その機能を発見するのが難しいから。さらにユースケースはThreadingやエラー処理などの共通機能をベースクラスで共有することができ大規模なチームにとって有益となる。

### Combine repositories

ニュースアプリではニュースと著者のデータ操作をそれぞれ扱う`NewsRepository`と`AuthorsRepository`があるかもしれない。`NewsREpository`が公開している`Article`クラスには著者の名前しか書かれていないが、著者の詳細な情報を画面に表示させた場合は`AuthorsRepository`から取得することができる。

このロジックは複数のリポジトリを含み複雑になる可能性があるため、`GetLatestNewsWithAuthorsUseCase` クラスを作成し、ViewModel からロジックを抽象化して可読性を高めている。これによりロジックを分離してテストすることが容易になりアプリの別の部分で再利用できるようになる。

このロジックはニュースリストの全ての項目をマッピングするので、データ層がmain safeであってもこの作業はメインスレッドをブロックしてはならない。なぜならメインスレッドが処理する項目の数が分からないからです。そのためこのユースケースはデフォルトのディスパッチャを使用してバックグランドスレッドに作業を移動させる。

Note: Roomライブラリを利用するとデータベース内の異なるエンティティ間の関係を照会することができる。データベースがsource of truthである場合、その作業をすべて行うクエリを作成することができなくなる。その場合はユースケースではなくリポジトリクラスを作成する方がよい。

## Other consumers

ドメイン層はUI層以外にもサービスやアプリケーションクラスなど他のクラスでも再利用することが可能。さらにTVやWearなど他のプラットフォームがモバイルアプリとコードベースを共有している場合、それらのUI層もユースケースを再利用してドメイン層の利点を全て享受することができる。

## Testing

ドメイン層はテストする際は一般的なテストガイダンスが適用される。UIテストでは開発者は通常ダミーのリポジトリを利用する。ドメイン層をテストする際もダミーのリポジトリを利用するのは良い慣習。

Last updated 2021-12-14 UTC.
