# Data layer

https://developer.android.com/jetpack/guide/data-layer

UI層にはUI関連の状態とUIロジックが含まれ、データ層にはアプリデータとビジネスロジックが含まれる。ビジネスロジックはアプリに価値を与えるもので、アプリデータの作成、保存、変更の方法を決定する実際のビジネスルールで構築されている。

このように関心ごとを分離することでデータ層を複数の画面で使用したり、アプリの異なる部分で情報を共有したり、ユニットテストのためにUIの外側でビジネスロジックを再現したりすることができる。

Note: このページで紹介する推奨事項とベストプラクティスは幅広いアプリに適用して、アプリの拡張、品質と堅牢性の工場、テストの容易化を図ることができる。ただし、これらはガイドラインとして扱い、必要に応じて要件に適合させる必要がある。

## Data layer architecture

データ層はそれぞれが0から多数のデータソースを含むことができるリポジトリで構成されている。アプリで扱うデータの種類ごとのリポジトリクラスを作成する必要がある。例えば、映画に関するデータであれば`MoviesRepository`、支払いに関するデータであれば`PaymentsRepository`を作成する。

リポジトリクラスは以下のタスクに対する責務がある。

* アプリ全体で利用するデータを公開する
* データの変化を一元化する
* 複数のデータソース間の矛盾を解決する
* アプリ全体からデータソースを抽象化する
* ビジネスロジックに接続する

各データソースクラスはファイル、ネットワーク、ローカルデータベースなど1つのデータソースだけを扱う責任を持つ必要がある。データソースクラスはデータ操作のためにアプリとシステムの橋渡しを行う。

他の層は決してデータソースに直接アクセスしてはならない。データ層の入り口は常にリポジトリクラスとする。ステートホルダークラスやユースケースクラスは直接の依存関係としてデータソースを持ってはならず、リポジトリクラスをエントリポイントと使用することでアーキテクチャの異なるレイヤーを独立して拡張することができる。

この層で公開されるデータは他のクラスによって改ざんされないように不変であるべき。イミュータブルなデータは複数のスレッドで安全に扱うことができる。

依存性注入のベストプラクティスに従い、リポジトリはコンストラクタでデータソースを依存性として受け取る。

Note: リポジトリが単一のデータソースしか含まず、他のリポジトリに依存しない場合、開発者はリポジトリとデータソースの責任をリポジトリに統合する。この場合、後のバージョンでリポジトリが他のソースからデータを扱う必要が出てきたときは機能を分割することを忘れてはならない。

## Expose APIs

データ層のクラスは一般的にCRUDを一発で実行する関数や時間経過によるデータ変更の通知を受け取るための関数を公開する。データ層はこれらのケースそれぞれについて以下を公開する必要がある。

* One-shot operations：操作の結果を通知するコールバックを提供する関数、または、RxJavaの`Single`、`Maybe`、`Completable`型を公開する
* 時間経過に伴うデータの変更を通知すること：KotlinではFlow,Javaではコールバック、もしくは、RxJavaの`Observable`,`Flowable`

## Naming conventions in this guide

このガイドではリポジトリは以下の命名とする。

データの型+`Repository`

データソースは以下の命名とする。

データの型+ソースの種類+`DataSource`

ソースの種類とは`Remote`, `Local`などで、例えば、`NewsRemoteDataSource`, `NewsLocalDataSource`。ソースが重要な場合はより明示的な命名にする。例えば、`NewsNetworkDataSource`, `NewsDiskDataSource`

データソースを利用するリポジトリはデータがどのように保存されるかを知る必要はないため、`UserSharedPreferencesDataSource`のように実装の詳細に基づいて命名しないようにする。これに従っておけばデータソースの実装を変更しても、そのデータソースを呼び出すレイヤーに影響を与えることはなくなる。

Note: データソースの新しい実装に移行する場合、データソースのインタフェースを作成し、データソースの実装を2つ持つことがある。この場合は、リポジトリが見るのはインタフェースだけでデータソースのクラスそのものは見えないのでデータソースのクラス名に実装の詳細に基づく命名にしても構わない。

## Multiple levels of repositories

より複雑なビジネス要件を含む場合、リポジトリは他のリポジトリに依存する必要があるかもしれない。これは関係するデータが複数のデータソースの集合体であったり、責務を別のリポジトリクラスにカプセル化する必要があったりするため。

例えば、ユーザー認証データを扱う`UserRepository`は`LoginRepository`や`RegistrationRepository`などの他のリポジトリに依存する可能性がある。

Note: 伝統的に開発者は複数のリポジトリを扱うクラスをマネジャークラスとして呼ぶことがあるが、この命名規則を使用しても構わない。

## Source of truth

各リポジトリは、single source of truthとなることが重要。single source of truthとは一貫性があり、正しく、最新のデータが含まれることで、リポジトリから公開されるデータはこれらであるべき。

single source of truthはデータベースなどのデータソースやインメモリキャッシュであっても構わない。リポジトリは異なるデータソースを組み合わせデータソース間の強豪を解決し、定期的にあるいはユーザーの入力イベントに応じて更新する。

アプリ内の異なるリポジトリは異なるsource of truthを持つ可能性がある。例えば、`LoginRepository`クラスはキャッシュを使用し、`PaymentsRepository`はネットワークデータソースを使用することがある。

オフラインファーストをサポートするためにはデータベースなどのローカルデータソースが推奨される。

## Threading

データソースやリポジトリを呼び出すにはメインスレッドから呼び出せるようなmain safeである必要がある。これらのクラスは長時間実行するブロック処理を行う場合、そのロジックの実行を適切なスレッドに移行させる責任を負う。例えば、データソースがファイルから読み込んだり、リポジトリが大きなリストに対してフィルタリングするのはmain safeであるべき。

ほとんどのデータソースはRoomやRetrofitが提供する`suspend`のようにmain safeなAPIを利用すれば良い。

スレッド処理については https://developer.android.com/guide/background を参考にする。KotlinであればCoroutinesを利用するのが推奨される。

## Lifecycle

データ層のクラスのインスタンスはGCのルートから到達可能である限りメモリ上に残る。

クラスがメモリ内のデータを含んでいる場合、そのクラスの同じインスタンスを特定の期間だけ再利用したいケースがある。これはクラスインスタンスのライフサイクルとも呼ばれる。

もし、そのクラスがアプリ全体にとって重要であるなら、`Application`クラスにスコープすることができる。そうすることでインスタンスはアプリのライフサイクルに従うようになる。一方、アプリ内の特定のフロー(登録やログイン)でのみ同じインスタンスを再利用する必要がある場合は、そのインスタンスをそのフローのライフサイクルを所有するクラスにスコープする。例えば、`RegistrationRepository`を`RegistrationActivity`や登録フローのNavigation Graphにスコープすることができる。

各インスタンスのライフサイクルはアプリ内で依存関係を提供する方法を決定する上で重要な要素である。依存関係が管理され、依存関係コンテナにスコープすることができる依存性注入のベストプラクティスに従うことが推奨されている。Androidにおけるスコープの詳細については https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0 を参考にする。

## Represent business models

データ層から公開したいデータモデルはさまざまなデータソースから取得する情報のサブセットかもしれない。離床的にはネットワークとローカルの両方のデータソースはアプリが必要とする情報のみを返すべきだがそうでないケースもよくある。

アプリは記事の内容と著者に関する基本情報を画面に表示するだけなので記事に関する情報は必要としないので、モデルクラスを分離し、必要とするデータのみをリポジトリに公開するのは良い方法である。

モデルクラスの分離は以下の点で有益

* データを必要なものだけにすることでアプリのメモリを節約できる
* アプリが日付を表現するために別のデータ型を利用する場合、外部データ型をアプリが使用するデータ型に合わせることができる
* モデルクラスが事前に定義されていれば大規模なチームメンバーが機能のネットワーク層とUI層を別に作業することができる

この方法を拡張してアプリのアーキテクチャの他の部分、例えばデータソースクラスやViewModelにも個別のモデルクラスを定義することができる。しかし、この場合、適切なドキュメント化とテストを行うために追加のクラスとロジックを定義する必要がある。少なくともアプリの他の部分が期待するものと一致しない場合には新しいモデルを作成することが推奨される。

## Types of data operations

データ層はその重要度によってUI指向、アプリ指向、ビジネス指向などの異なるタイプのオペレーションを扱うことができる。

### UI-oriented operations

UI指向の操作はユーザーが特定の画面にいるときのみ意味があり、その画面から離れるとキャンセルされる。例えば、データベースから取得したデータを表示するような場合。

UI指向の操作は通常UI層によって起動され、呼び出し元(ViewModelなど)のライフサイクルに従う。

### App-oriented operations

アプリ指向の操作はアプリが開いている限り関連する。アプリが閉じられたりプロセスが強制終了されたりすると、これらの操作はキャンセルされる。例えば、ネットワークリクエストの結果をキャッシュしてあとで必要な時に使えるようにすることができる。

これらの操作は通常`Application`クラス、またはデータ層のライフサイクルに従う。

### Business-oriented operations

ビジネス指向の操作はキャンセルできない。プロセスが死んでも耐えうるものでなければならない。例えばユーザーが自分のプロフィールに投稿したい写真のアップロードを終了させるようなもの。

ビジネス指向の操作は`WorkManager`を使用することが推奨される。

## Expose errors

リポジトリやデータソースとのインタラクションは成功するか失敗した時に例外を投げるかのどちらか。CoroutinesやFlowではエラー処理機構を使用する必要がある。`suspend`関数によって引き起こされる可能性のあるエラーについてはtry/catchブロックを使用し、Flowでは`catch`を利用する。このアプローチではUI層はデータ層を呼び出す際に例外を処理することが期待される。

データ層はsまざまな種類のエラーを理解し、処理することができる。また、`UserNotAuthenticatedException`のようなカスタム例外を使用してエラーを公開することもできる。

Note: データ層とのインタラクションの結果をモデル化するもう一つの方法は`Result`クラスを使用すること。このパターンは結果の処理の一部として起こりうるエラーをモデル化する。データ層は`T`の代わりに`Result<T>`を返すのでUIは特定のシナリオで発生しうる既知のエラーを認識することができ、`LiveData`のように適切な例外処理を持たないリアクティブプログラミングAPIに必要なもの。

Coroutinesでのエラーについては https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c を参考にする。

## Common tasks

以下のセクションではAndroidアプリで一般的な特定のタスクを実行するためのデータ層の使用方法とアーキテクチャについて例をあげて説明する。この例では前述したニュースアプリをベースにしている。

### Make a network request

ネットワークへのリクエストはAndroidアプリが行う可能性のある最も一般的なタスクの一つ。ニュースアプリはネットワークから取得した最新のニュースをユーザーに表示する必要がある。そのためアプリにはネットワーク操作を管理する`NewsRemoteDataSource`のようなデータソースクラスが必要となる。アプリの他の部分に情報を公開するために`NewsRepository`を作成する。

ユーザーが画面を開いた時に常に最新のニュースが更新されていることが必要です。したがってこれはUI指向の操作となる。

### Create the data source

データソースは`ArticleHeadline`インスタンスのリストである最新ニュースを返す関数を公開する必要がある。データソースはネットワークから最新のニュースを取得するためのmain safeな方法を提供する必要がある。そのためにはタスクを実行する`CoroutineDispatcher`または`Executor`に依存する必要がある。

ネットワークへのリクエストは`fetchLatestNews()`によって処理されるone-shotコール。

`NewsApi`インタフェースはネットワークAPIクライアントの実装を隠し、`Retrofit`, `HttpURLConnection`かどうかに違いはない。インタフェースに依存することでAPIの実装をアプリ内で入れ替えられるようになる。

Key Point：インタフェースに依存することでアプリ内でAPIの実装を入れ替えられるようになり、拡張性や依存関係の置き換えが容易になるだけでなく、テストにダミーのデータソースを注入することができるためテスト容易性も向上する。

### Create the repository

このタスクでリポジトリクラスに余計なロジックは必要ないため`NewsRepository`はネットワークデータソースのプロキシとして昨日する。この抽象化されたレイヤーを追加することの利点は次のセクションで説明する。

UI層で直接リポジトリクラスを消費する方法については https://developer.android.com/jetpack/guide/ui-layer を参考にする。

### Implement in-memory data caching

ニュースアプリに新しい要件が導入され、ユーザがー画面を開いた時に以前リストがあった場合はキャッシュされたニュースを表示する必要があり、それ以外の場合はネットワーク経由で最新のニュースを取得する必要がある。

新しい要件ではユーザーがアプリを開いている間、アプリは最新のニュースをメモリに保持する必要がある。これはアプリ指向の操作となる。

#### Caches

インメモリのキャッシュを追加することでユーザーがアプリを使用している間データを保持することができる。キャッシュはある情報を特定の期間、つまりユーザーがアプリを使用している間、メモリに保存することを示す。キャッシュの実装はさまざまな形態をとることができ、単純なミュータブル変数から複数スレッドからの操作を保護するクラスまでさまざま。ユースケースに応じてキャッシュはリポジトリやデータソースクラスに実装することができる。

#### Cache the result of the network request

単純化のため、`NewsRepository`は最新のニュースをキャッシュするためにミュータブル変数を使用する。異なるスレッドからの操作を保護するために、`Mutex`を使用している。ミュータブルステートと並行性の詳細は https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#shared-mutable-state-and-concurrency を参考にする。

#### Make an operation live longer than the screen

ネットワークリクエストの実行中にユーザーが離れた場合、そのリクエストはキャンセルされ結果はキャッシュされないので、`NewsRepository`はこのロジックを実行するため呼び出し元の`CoroutineScope`を使用するべきでない。その代わりライフサイクルに接続されている`CoroutineScope`を使用する必要がある。最新ニュースの取得はアプリ指向の操作である必要がある。

依存性注入のベストプラクティスに従うために、`NewsRepository`は独自の`CoroutineScope`を作成する代わりにコンストラクタでパラメータとして受け取る必要がある。リポジトリはバックグラウンドスレッドでほとんどの作業を行う必要があるため、`CoroutineScope`は`Dispatchers.Default`または独自のスレッドプールで構成する必要がある。

`NewsRepository`は外部の`CoroutineScope`とアプリ指向の操作を行う準備ができているためデータソースの呼び出しを行い、その結果をそのスコープで起動した新しい coroutine で保存する必要がある。

`async` は外部スコープでコルーチンを起動するために利用され、`await` は新しいコルーチン上で呼ばれネットワークリクエストが戻ってきて結果がキャッシュに保存され馬で中断される。もしユーザーが画面から離れたら、`await`はキャンセルされるが`async`の中のロジックは実行され続ける。

`CoroutineScope` のパターンについては https://medium.com/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad を参考にする。

### Save and retrieve data from disk

例えば、ブックマークしたニュースやユーザーのお気に入りなどのデータを保存しておきたい場合、ユーザーがネットワークに接続していない場合やプロセスが再起動した後もアクセスできる必要がある。

もし、プロセスが再起動した後もアクセスする必要があるデータであれば、いずれかの方法でディスクに保存する必要がある。

* 照会が必要で、参照整合性が必要で部分更新が必要な大規模なデータセットの場合は、`Room`データベースに保存する
* 取得と設定のみが必要な小規模なデータセットには`DataStore`を利用する
* JSONオブジェクトのようなデータの塊の場合はファイルを利用する

single source of truthの章で記述したように各データソースは1つのソースのみで動作し、特定のデータ型に対応する。データソースを使用するクラスはデータがどのように保存されるのかを知ってはいけない。

#### Room as a data source

各データソースは特定の種類のデータに対して1つのソースのみと連携する責務があるため`Room`データソースはDAOまたはデータベース自体をパラメータとして受け取ることになる。

DAOはテストで簡単に置き換えることができるインタフェースなので余計なロジックが必要なければリポジトリに直接DAOを注入することも可能な場合がある。

#### DataStore as a data source

`DataStore`はユーザー設定のようなKey-Valueペアを格納するのに適している。例えば、時間の形式、通知の設定、ユーザーが読んだあとにニュースを表示するか隠すかなどがある。`DataStore`はプロトコルバッファをもつ型つきオブジェクトを格納することもできる。

他のオブジェクトと同様に`DataStore`にバックアップされたデータソースは特定のタイプやアプリの特定の部分に対応するデータを含む場合がある。`DataStore`の場合、`DataStore`の読み込みは値が更新されるたびに発行されるFlowとして公開されるのでsingle source of truthとなる。このため関連するプリファレンスは同じ`DataStore`に格納する必要がある。

例えば、通知関連のプリファレンスだけを扱う`NotificationsDataStore`とニュース画面に関するプリファレンスだけを扱う`NewsPreferencesDataStore`を用意することができる。そうしておけばその画面に関連するプリファレンスが更新された時にだけFlowが発行されるので、更新の範囲をより明確にすることができる。また、ニュース画面が表示されている間だけ生きることができるのでオブジェクトのライフサイクルを短くすることができる。

#### A file as a data source

JSONオブジェクトやBitmapのような大きなオブジェクトを扱う場合、`File`オブジェクトを操作してスレッドを切り替える処理が必要となる。

### Schedule tasks using WorkManager

例えば、ニュースアプリに新しい要件が導入され、デバイスが充電中であり、従量課金されないネットワークに接続されている場合に限り、定期的かつ自動的に最新ニュースを取得するオプションをユーザーに提供しなければならない。これはビジネス指向の操作となる。この要件によりユーザーはアプリを開いた時にデバイスがネットワークに接続していなくても最新のニュースを見ることができるようになる。

`WorkManager`は非同期で信頼性の高い作業を簡単にスケジュールすることができ製薬の管理も行うことができるので、永続化の作業のために推奨されるライブラリ。
`FetchLatestNewsWorker`は最新のニュースをフェッチしてディスクにキャッシュするため`NewsRepository`を依存関係に持つ。

このタイプのタスクのビジネスロジックは独自のクラスにカプセル化され別のデータソースとして扱われる必要がある。`WorkManager`はすべての制約が満たされた時にバックグラウンドスレッドで作業が実行されることを確認することだけを担当する。このパターンに従えば、必要に応じて異なる環境での実装を素早くこうかんすることができる。

このニュース関連のタスクは`NewsRepository`から呼び出される必要があり、新しいデータソースを依存関係として取ることになる。

このタイプのクラスは`NewsTasksDataSource`や`PaymentsTasksDataSource`などデータの名前にちなんで命名される。特定の種類のデータに関連する全てのタスクは同じクラスにカプセル化する必要がある。

タスクがアプリの起動時にトリーがされる必要がある場合、イニシャライザーからリポジトリを呼びだすApp Startupライブラリを利用して、`WorkManager`リクエストをトリガーすることが推奨される。

### Testing

依存性注入のベストプラクティスはアプリをテストする時に役立つ。外部リソースと通信するクラスあhインタフェースに依存するのが便利。ユニットテストをする場合はダミーを注入することでテストを決定的かつ信頼性の高いものにすることができる。

#### Unit tests

データ層をテストする際は一般的なテストのガイダンスが適用される。ユニットテストでは必要に応じて実際のオブジェクトをシユし、ファイルからの読み込みやネットワークからの読み込みなど、外部ソースにアクセスする依存関係についてはフェイクを利用する。

#### Integration tests

外部ソースにアクセスする統合テストは実機で実行する必要があるため、決定性が低くなる傾向がある。統合テストの信頼性を高めるために制御された環境下でテストを実行することが推奨される。

データベースについては`Room`ではテストで完全に制御できるインメモリデータベースを作成することができる。

ネットワークについては`WireMock`や`MockWebServer`などのライブラリがあり、HTTP, HTTPSの呼び出しを偽装して想定通りにリクエストが行われたかどうかを検証することができる。

Last updated 2021-12-14 UTC.
