# UI layer

https://developer.android.com/jetpack/guide/ui-layer

UIの役割はアプリのデータを画面に表示することであり、ユーザーとのインタラクションの主要なポイントになることである。ユーザー操作(ボタンのタップなど)や外部からの入力(ネットワークの黄桃など)によりデータが変更されるとUIはその変更を反映して更新されなければいけない。事実上、UIはデータ層から取得されたアプリの状態を視覚的に表現したもの。

しかし、データ層から取得するアプリのデータは通常表示する必要のある情報とは異なる形式になっている。例えば、UIに必要なのはデータの一部だけかもしれないし、ユーザーに関連する情報を表示するために2つの異なるデータソースをマージする必要があるかもしれません。UI層はアプリデータの変更をUIが提示できる形に変更し、それを表示するパイプラインです。

Note: このページで紹介する推奨事項やベストプラクティスは幅広いアプリに適用することができ、アプリの拡張、品質と堅牢性の向上、テストの容易性を実現します。ただし、ガイドラインとして扱い必要に応じて要件に適合させる必要がある。

## A basic case study

ユーザーが読むためのニュース記事を取得するアプリを考える。このアプリは以下のようなことができる。

* 読むことができる記事を表示する
* カテゴリ別に記事を閲覧する
* サインインして、特定の記事をブックマークする
* 一部のプレミアム機能を利用することができる

以下ではこの例をケーススタディとして単方向データフローの原則を紹介し、この原則がUI層でどう役立つのかを説明する。

## UI layer architecture

UIという用語はデータを表示するActivity, FragmentなどのUI要素を指し、そのために使用するAPI(ViewsやJetpack Compose)とは無関係である。データ層の役割はアプリデータを保持、管理しアクセスを提供することなのでUI層は以下のステップを実行する必要がある。

1. アプリデータを消費しUIが簡単にレンダリングできるデータに変換する
1. UIレンダリング可能なデータを消費し、ユーザーに提供するためのUI要素に変換する
1. 組み立てられたUI要素からユーザー入力イベントを受け取り必要に応じてUIデータに変換する
1. 1-3の手順を必要なだけ繰り返す

特にこのガイドでは以下の作業と概念について説明する。

* UIの状態を定義する方法
* UIの状態を生成・管理する手段としての単方向データフロー
* 単方向データフローの原則に従って、観測可能なデータ型を使ってUIの状態を公開する方法
* 観測可能なUIの状態を消費するUIをどのように実装するか

これらのうち最も基本的なものはUIの状態の定義である。

## Define UI state

先ほどの事例だと、UIは記事のリストとそれぞれの記事のためのいくつかのメタデータと一緒に表示する。アプリがユーザーに提示するこの情報はUIの状態です。

言い換えれば、UIがユーザーが見るものであるならUIの状態はアプリが言う「ユーザーが見るべきもの」である。UIはUIの状態を視覚的に表現したもので、UIの状態が変更されると即座にUIに反映される。

UIは画面上のUI要素とUIの状態の結合の結果である。

### Immutability

上記のコード例はイミュータブルである。イミュータブルであることの主な利点は、ある瞬間のアプリの状態を保証してくれることで、これによりUIは状態を読み取りそれに応じてUI要素を更新すると言う単一の役割に集中することができる。その結果、UI自身が唯一のデータソースである場合を覗き、UIの状態を直接変更することは決してない。この原則に違反すると同じ情報のデータソースが複数になりデータの不整合やバグを引き起こす子ことになる。

例えば、ケーススタディのUIの状態から`NewsItemUiState`のブックマークされたフラグがActivityで更新された場合、そのフラグは記事のブックマーク状態のソースとしてデータ層と競合することになる。このようなアンチーアターンを防ぐためにImmutableなデータクラスは非常に有効。

Key Point：データのソースまたは所有者のみが公開するデータの更新に責任を負うべき

### Naming conventions in this guide

このガイドでは、UIの状態を示すクラスは記述する画面または画面の一部の機能に基づいて命名され規約は以下

機能 + `UiState`

例えば、ニュースを表示する画面の状態は `NewsUiState`、ニュース項目の状態は `NewsItemUiState`

## Manage state with Unidirectional Data Flow

前章ではUIの状態がUIのレンダリングに必要な不変のスナップショットであることを説明した。しかしアプリのデータは動的な性質をもっているため時間が経つと状態が変化する可能性がある。これはユーザーとの対話、アプリを生成するために使用する基礎データを変更する他のイベントが原因である可能性がある。

これらのインタラクションを処理するためにMediatorが必要で各イベントに適用するロジックを定義しUIの状態を作成するために必要な変換をバックデータのソースに対して実行する。これらのインタラクションやロジックはUI自体に格納されるかもしれないがすぐに扱いにくくなる。その結果コードの境界がはっきりしない密結合の集合体となりテストの容易性に影響を与える可能性がある。UIの状態が非常に単純でない限りUIの唯一の責任はUIの状態を消費して表示することであるべき。

この章では責任分担を実現するためのアーキテクチャパターンである Unidirectional Data Flow について説明する。

### State holders

UIの状態を生成する役割を持ち、その作業に必要なロジックを含むクラスをステートホルダーと呼ぶ。ステートホルダーは対応するUI要素の範囲によってさまあまな大きさがあり、アプリの下部バーのような単一のウィジェットから画面全体やナビゲーション先まで多岐にわたる。

後者の場合、典型的な実装はViewModelのインスタンスですがアプリの要件によっては単純なクラスで十分
な場合がある。例えばケーススタディのニュースアプリでは`NewsViewModel`クラスをステートホルダーとして使用している。

Key Point：ViewModel型はデータそうにアクセス可能な画面レベルのUIの状態を管理するための推奨実装で、さらに設定の変更にも自動的に対応する。ViewModelクラスはアプリ内のイベントに適用されるロジックを定義し、その結果として更新された状態を生成する。

UIとその状態の間の共依存関係をモデル化する方法はたくさんあるが、UIとViewModelの相互作用はイベントの入力と状態の出力として理解しやすい。

状態が下に流れ、イベントが上に流れるパターンをUnidirectional Data Flowと呼ぶ。このパターンがアプリのアーキテクチャに与える影響は以下の通り。

* ViewModelはUIガショウヒスルジョウタイヲホジシコウカイスル。UIの状態はViewModelによって変換されたアプリケーションデータである
* UIはユーザーイベントをViewModelに通知する
* ViewModelはユーザーアクションを処理し、状態を更新する
* 更新された状態はUIにフィードバックされ、レンダリングされる
* 上記は状態の変化を引き起こすあらゆるイベントに対して繰り返す

ナビゲーションの目的地や画面についてはViewModelがリポジトリやユースケースと連携してデータを取得し、状態の変化を引き起こす可能性のあるイベントの影響を取り入れながらUIの状態へ変換する。

ケーススタディのニュースアプリでユーザーが記事のブックマークを要求することは状態の変化を日ココス可能性のあるイベントの一例。状態の生産者としてViewModelはUIの状態の全てをデータに入力し、UIが完全にレンダリングされるために必要なイベントを処理するために必要あん全てのロジックを定義する責任を負っている。

### Types of logic

記事のブックマークはアプリに価値を与えるのでビジネスロジックの一例。定義することが重要なロジックには異なる種類がある。

* ビジネスロジック：状態の変化に対して何をするか
* UI振る舞いロジック、UIロジック：状態の変化を画面に表示する方法。例えばAndroidリソースを使って画面に表示するテキストを取得したり、ユーザーがボタンをクリックした時に特定の画面に移動したり、Toast,Snackbarでメッセージを画面に表示したりすること

特にContextのようなUIタイプを含む場合のUIロジックはCiewModelではなくUIが持っている必要がある。UIが複雑化しテスト容易性や懸念事項の分離を優先してUIロジックを別のクラスに以上したい場合はステートホルダーとしてシンプルなクラスを作成することができる。UIで作成されたシンプルなクラスはUIのライフサイクルに反っているためAndroid SDKの依存関係を排除することができる。

ステートホルダーの詳細とUIの構築を支援するコンテキストへの適合性については https://developer.android.com/jetpack/compose/state#managing-state を参考にする。

### Why use UDF?

Unidirectional Data Flowは以下を可能にする。

* データの一貫性：single source of truth
* テスト容易性：状態が分離されているためUIから独立してテストが可能になる
* 保守性：状態の変化はユーザーイベントとそこから取得するデータソースの両方の結果である明確に定義されたパターンに従う

## Expose UI state

UIの状態を定義し、その状態の生成をどのように管理するかを決めたら次のステップは生成された状態をUIに表示すること。状態の生成を管理するためにUnidirectional Data Flowを使用しているので生成される状態はストリームであると考えることができる。つまり、状態の複数のバージョンが時間とともに生成される結果、LiveData, StateFlowのような観測可能なデータホルダーとして公開する必要がある。これはViewModelから直接データを手動で取得しなくてもUIが状態に加えられた変化に反応できるようにするため。またこれらの型は常に最新バージョンの状態をキャッシュしておくという利点もあり設定変更後に素早く状態を復元するのに便利。

Note: Jetpack ComposeアプリではUIの状態を公開するために`mutableStateOf`や`snapshotFlow`などComposeのAPIを使用することができる。このガイドで紹介する`StateFlow`や`LiveData`などの観測可能なデータホルダーは拡張機能を利用してComposeで簡単に消費することができる。UIで公開されるデータが比較的単純な場合、データをUIステート型でラップするとステートホルダーと画面やUI要素との関係がわかりやすい。さらにUI要素がより複雑になればUI要素のレンダリングに必要な情報の追加が容易になる。

UiStateのストリームを作成する一般的な方法はmutableストリームをViewModelからimmutableストリームとして公開すること。例えば：`MutableStateFlow<UiState>`を`StateFlow<UiState>`として公開すること。

ViewModelは内部で応対を変化させるメソッドを公開し、UIが消費できるように更新を発行することができる。例えば非同期で実行する必要がある場合は、`viewModelScope`を使用してコルーチンを起動する。

Note: 上記の例はViewModel嬢の関数を通じて状態を変化させるパターンで最も一般的な実装の一つ。

### Additional considerations

上記に加え、UIの状態を公開する場合は以下に考慮すること。

* UIの状態のオブジェクトは互いに関連する状態を処理する必要がある
  * これは矛盾を少なくし、コードを理解しやすくすることにつながる。例えば複数の状態を組み合わせたププロパティを定義する。
* UIの状態：シングルストリームかマルチストリームか？
  * UIの状態を単一のストリームで公開するか複数のストリームで公開するかを選択するための重要な指針は「公開されるアイテム間の関係：。シングルストリームで公開する最大の利点は利便性とデータの一貫性。消費者はどの瞬間でも常に最新の情報を取得することができる。
    * 関連性のないデータ型：
      * UIをレンダリングするために必要ないくつかの状態は互いに完全に独立している場合がある。このような場合とくにこれらの状態のうち一方が他方よりも頻繁に更新される場合、これらの状態を束ねるコストが利益を上回る可能性がある
    * UiStateの差分：
      * UiStateオブジェクトにフィールドがおいほど、そのフィールドの1つが更新された結果としてストリームが発火される可能性が高くなる。Viewは連続したイベントが異なるものか同じものかを判断する差分メカニズムを持っていないため毎回ビューの更新を引き起こしてしまう。`Flow`や`LiveData`の`distinctUntilChanged()`などのメソッドが必要かもしれない

## Consume UI state

UIが`UiState`オブジェクトのストリームを消費するために観測可能な型のオペレーターを利用する。例えば、`LiveData`では`observe()`、`Flow`では`collect()`。

UIが観測可能なデータホルダーを消費する時、UIのライフサイクルを気にする必要がある。ビューがユーザーに表示されていない場合はUIの状態を監視すべきではないので重要である。このトピックについては https://medium.com/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda を参考にする。`LiveData`の利用時は`LifecycleOwner`がライフサイクルをケアしてくれる。`Flow`の利用時は`repeatOnLifecycle`を利用して適切にハンドリングするのがベストな方法。

Note: `StateFlow`を利用した例ではアクティブなコレクターがない時は処理を停止しないがFlowがどのように実装されているかを知らないかもしれない。このようにライフサイクルを意識したコードを書くことでコレクター以下のコードの変化を意識しなくて済むようになる。

### Show in-progress operations

読み込み中の状態をシンプルに表現する方法は`UiState`クラス内に`Boolean`のフィールドを定義すること。

### Show errors on the screen

UIでエラーを表示するのは`Boolean`で表示、非表示を表現できるので読み込み中と類似している。しかし、エラーはユーザーに表示するメッセージを含んでいたり、リトライのアクションを保持している可能性がある。そのため、エラーはデータクラスでモデル化する必要がある。

ニュースの読み込み中に失敗するケースではユーザに1つ、もしくは複数のメッセージを表示したいかもしれない。

エラーメッセージはsnackbarsなどのUI要素で表現することができる。UIイベントをどのように生成、消費するのかについては https://developer.android.com/jetpack/guide/ui-layer/events を参考にする。

## Threading and concurrency

ViewModelで処理されるいずれのタスクもメインスレッドから呼び出しmain-safeであるべき。そのためデータ層やドメイン層は異なるスレッドで呼び出す責務がある。

ViewModelが長時間の処理を動作させる場合もバックグラウンドスレッドでロジックを移す責任がある。Coroutinesはこれらを管理する良い方法を提供しており、Jetpack Architecture Componentsもそれらをサポートしている。AndroidアプリでのCoroutinesの利用については https://developer.android.com/kotlin/coroutines を参考にする。

## Navigation

アプリの遷移はイベントに似た発火によってよく動作する。例えば、サインインを行う`SignInViewModel`では、`UiState`が持つ`isSignedIn`が`true`で表現されることがある。遷移のトリガーは1度だけ消費されるべきで、Navigation Componentを利用すべき。

## Paging

Pagingライブラリは`PagingData`が呼び出されUIで消費される。`PagingData`で表現されアイテムを含んでおりイミュータブルでないためイミュータブルなUIの状態ないで表現するべきなく、。代わりに、ViewModelで独立したストリームとして公開するべき。

## Animations

スムーズな遷移を提供するために2番目の画面のデータ読み込みのためにアニメーションの開始を待機させたいケースがあるかもしれない。そういったケースでは`postponeEnterTransition()`, `startPostponedEnterTransition()` API が提供されている。これらのAPIでは2番目の画面のUI要素を利用してアニメーションさせる方法を提供している。詳細は https://github.com/android/animation-samples/tree/main/Motion を参考にする。

Last updated 2021-12-14 UTC.
