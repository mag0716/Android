# UI events

https://developer.android.com/jetpack/guide/ui-layer/events

UIイベントはUI層で処理されるべきアクションでUIまたはViewModelによって処理される。最も一般的なイベントの種類はユーザーイベント。ユーザーはアプリとのインタラクションによってユーザーイベントを生成する。例えば画面をタップしたりジェスチャーを生成したりするなどです。UIは`onClick()`ルシなーなどのコールバックを使用してこれらのイベントを消費する。

Key Terms：
UI：UIを処理するViewベースまたはComposeのコード
UIイベント：UI層で処理されるべきアクション
ユーザーイベント：ユーザーがアプリと対話するときに生成するイベント

ViewModelは通常特定のユーザーイベントのビジネスロジックを処理する責任を持つ。通常、ViewModelはUIが呼び出すことのできる関数を公開することでこの処理を行う。ユーザーイベントにはUIが直接処理できるUI動作ロジックが含まれている場合もある。例えば、別画面へ遷移したり、Snackbarを表示したりする場合など。

ビジネスロジックは同じアプリを異なるモバイルプラットフォームやフォームファクタで使用しても変わらないが、UI動作ロジックは実装の詳細でこれらのケースで異なる可能性がある。UI層のページではこれらのタイプのロジックを以下のように定義する。

ビジネスロジック：決済やユーザー設定の保存など状態の変化をどのように処理するかということ。通常、ドメイン層とデータ層がこのロジックを処理する。このガイドではビジネスロジックを処理するクラスはArchitecture ComponentsのViewModelが利用される
UI動作ロジック、UIロジック：状態の変化を表示する方法。例えば画面遷移のロジックやユーザーのメッセージの表示方法などを示し、UIはこのロジックを処理する。

Note: このページで紹介する推奨事項やベストプラクティスは幅広いアプリに適用し、アプリの拡張性、品質と堅牢性の向上、およびテストの容易化を実現できる。ただし、ガイドラインとして扱い必要に応じて要件に適合させる必要がある。

## UI event decision tree

次の図は特定のイベントのユースケースを処理するための最適なアプローチを見つけるためのツリーを示す。このガイドの残りの部分ではこれらのアプローチについて詳しく説明する。

## Handle user events

UI要素の状態の変更に関連するイベントであれば、UIはユーザーイベントを直処理することができる。例えば、拡張可能なアイテムの状態など。そのイベントが画面上のデータを更新するなどのビジネスロジックを実行する必要がある場合はViewModelによって処理されるべき。

次の例ではUI要素の拡張(UIロジック)と画面上のデータの更新(ビジネスロジック)のために異なるボタンがどのように使用されるかを示している。

### User events in RecyclerViews

アクションがRecyclerViewアイテムやカスタムビューのようにUIツリーのさらに下層で生成される場合、ViewModelはユーザーイベントを処理するものであるべき。

例えば、`NewsActivity`からの全てのニュースアイテムがブックマークボタンを含んでいるとする。ViewModelはブックマークされたニュースアイテムのIDを知る必要がある。ユーザーがニュースアイテムをブックマークするとき、RecyclerViewアダプタはViewModelから公開されている `addBookmark(newsId)` を呼び出してしまうと、ViewModelへの依存を必要としてしまう。代わりに、ViewModelは`NewsItemUiState`というステートオブジェクトを公開しその中にイベントを処理するためんの実装を含めている。

Warning：RecyclerViewアダプタにViewModelを渡すことは密結合になるので好ましくない

Note：もう一つの一般的なパターンはRecyclerViewアダプタがユーザーアクションのためのコールバックインタフェースを持つこと。その場合、ActivityやFragmentはバインディングを処理し、コールバックインタフェースから直接ViewModelの関数を呼び出すことができる。

#### Naming conventions for user event functions

このガイドではユーザーイベントを処理するViewModel関数には処理するアクションに応じた動詞の名前をつけている。例えば、`addBookmark(id)`, `logIn(username, password)`

## Handle ViewModel events

ViewModelから発信されるUIアクションは常にUIの状態を更新する結果となる必要がある。これはUDFの原則に従ったもの。これは設定変更後にイベントを再現できるようにし、UIアクションが失われないことを保証する。オプションとしてはsaved stateモジュールを使用すればプロセスが終了した後でもイベントを再現できるようにすることもできる。

UIアクションをUIの状態にマッピングすることは必ずしも単純なプロセスではないがよりシンプルなロジックに繋がる。例えば、UIを特定の画面に移動させる方法を決定するだけでは思考プロセスは終わらないはず。さらに考えてユーザーフローをUIの状態でどのように表現するかを考える必要がある。つまりUIがどのようなアクションを起こすべきかを考えるのではなくそのアクションがUIの状態にどのように影響を与えるのかを考える。

Key Point：ViewModelのイベントは常にUIの状態を更新するものでなければならない

例えば、ログイン画面でユーザーがログインしているときにホーム画面に移動する場合を考える。これをUIの状態としてモデル化すると次のようになる。

このUIは`isUserLoggedIn`の変化に反応し必要に応じて正しい目的地に遷移させる。

Note：このセクションのコード例ではコルーチンとライフサイクルを考慮したコンポーネントの使用方法について理解していることが必要。

### Consuming events can trigger state updates

UIで特定のViewModelイベントを消費する子tで他のUIの状態の更新が発生する場合がある。例えば、ユーザーに何かが起こったことを知らせるために画面に一時的なメッセージを表示する場合、メッセージが画面に表示された時点でUIはViewModelに通知し、別の状態の更新をトリーがする必要がある。そのUIの状態は以下のようにモデル化することができる。

ViewModelはビジネスロジックがユーザーがに新しいメッセージを表示する必要がある場合、以下のようにUIの状態を更新する。

ViewModelはUIがどのようにメッセージを画面に表示しているかを知る必要はなく表示する必要のあるメッセージがあることだけを知っていれば良い。一時的なメッセージが表示されるとUIはViewModelにそのことを通知する必要があり、UIの状態を更新が発生する。

## Other use cases

UIイベントのユースケースをUIの状態の更新で解決できないと考えるなら、アプリ内のデータの流れを最高する必要があるかもしれない。以下の原則を考える必要がある。

* 各クラスは自身の責務に関することだけを処理するべき
  * UIはナビゲーション呼び出し、クリックイベント、権限要求の取得など画面固有の動作ロジックを担当すr。ViewModelはビジネスロジックを含み下位回想からの結果をUIの状態に変換する
* イベントがどこで発生するのかについて考える
  * このガイドの最初に示したツリーに従って各クラスが担当するものを処理するようにする。例えばイベントがUIから発生し、その結果がナビゲーションイベントである場合、そのイベントはUIで処理されなければならない。いくつかのロジックはViewModelに委譲されるかもしれないがイベントの処理を完全にViewModelに委譲することはできない
* 複数の消費者がいてイベントが複数回消費されることを心配しているのであればアーキテクチャの再考が必要かもしれない
  * 複数の消費者が同時に動作することで一度だけ配信される契約を保証することが難しくなり、複雑さと微妙な動作が増加する。この問題がある場合は、UIツリーの上位にこれらの懸念を押し出すことを検討する。階層構造の上位にスコープされた別のエンティティが必要な場合がある。
* 状態がいつ消費されるかについて考える
  * 特定の状況下ではアプリがバックグラウンドにあるときに状態を消費し続けたくない場合がある。そのような場合はUIがフォアグラ運度にあるときに状態を消費することを検討する

Note：いくつかのアプリではKotlinのChannelやリアクティブストリームを使用してViewModelイベントがUIに公開されrているのを見たことがあるかもしれない。これらの方法ではイベントが失われず一度だけ消費されることを保証するために通常イベントラッパーなどの回避策が必要となる。

回避策が必要なのはこれらのアプローチに問題があることを示している。ViewModelからイベントを公開することの問題点はUDFのstate-down-events-upの原則に反してしまう。

もしそのような状況にあるのであれば、単発のViewModelイベントがUInいとって実際に何を意味するのかを再考し、それをUIの状態に変換する。UIの状態はある時点のUIをよりよく表し、より多くの配信と処理の保証を与え、テストが容易で、他の部分と一貫して統合することができる。

Last updated 2021-12-14 UTC.
